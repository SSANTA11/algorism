 // 7주차 총 복습
//1장 안함
//2장 시간복잡도와 점근적 표기
	// 수도코드보고 시간복잡도 점근적 표기(갤러리 참고!)
		//(1) O(n^2)
		//(2) O(n^3)
		//(3) O(n)
		// 21번은 수업 중 연습, 22번은 시험 100% 출제!!!(59pg)
// 3장 분할정복알고리즘 (3.1,.3.2, 3.3만 출제)
	// 왜 분할 정복인가?를 알자
	// 합병 정렬의 단순 구조 예시는 너무 쉽다.(예.70pg)
	// 이전에 작성한 합병정렬 C코드 형태나 수도 코드 형태로 출제될 수있다.
	// 합병 정렬 이후에는 퀵소트를 했는데, 이때 시간복잡도 중요!
	// 합병정렬과 퀵정렬의 장단점과 같은 특징을 모두 암기해야한다.
	// 퀵소트 알고리즘을 암기해야한다 3장 ppt 23pg 의 모든 내용을 c코드 전문이나 슈도 코드로 알고 있어야한다. 암기는 둘다! 출제는 어느것으로 될지 모름
	// 연습문제15번 분할정복 과정  6 7 3 2 9 12 17 19 13 15 14 ,피봇은 14(피봇 선정은 문제에서 요구하는대로)(+ 갤러리 참고, ppt23)
	// 14를 제일 왼쪽으로 옮기고 본래 가장 좌측에 있던 요소를 원래 14자리로 서로 교환
	// partition()
	// while i<=j
	// while A[i]<pivot and i<=j) i++; ->피봇보다 작은 케이스
	// while A[j][<pivot and i<=j) j--; swap; ->피봇보다 큰 케이스
	// if (i<j) A[i]<->A[j]; A[left]<->A[right]; //left가 피봇!! right가 (....j??? 확실히 하자!)
	// 7부터 12까지는 i는 계속 ++만 하다 17에선 swap해준다.
	// j는 반대로 --를 하다가 피봇보다 작은 경우 swap해준다.----?
	// i와 j가 엇갈리려는 순간 j의 자리가 피봇자리이다.
	// 피봇 14는 8번째에 위치한다.
	// 떄문에 적어도 알고리즘은 암기!! 

	// 3.5 장에 피보나치와 분할정복 알고리즘의 주의점을 암기

	// 그리디 알고리즘에 대한 기본 정의는 알아야 한다.
	// 4장 예제 문제 148pg 3번 4번 참고!
	// 
	// 그래프 ppt
		// 그래프 ppt의 노드 관련 내용 나올 수도...
		// 그래프 ppt에서 그래프 구현 파트의 인접 행렬과 인접 리스트로 표현하는법(갤러리 참고)(Adjacency MAtrix, Adjacency List)(그래프 ppt 14페이지)
		// 그래프의 순회, 그래프 탐색
			// (깊이우선 탐색 & 너비우선 탐색)-->가중치를 보지는 않는 탐색방법
			// 깊이우선 탐색(노드의 알파벳 순서 기준으로 이동)으로 순회(traivals)한다. (갤러리 참고, 2장 전후)(스택을  사용)(그래프 ppt 49)
				// 특정 노드에 방문시에 스택에 노드를 집어넣고 방문이 확정되었을떄는 배열 visited에 F를 T로 교환햐여 확정한다.
				// 그러면 신장트리(spanning tree)가 된다. (최소해 보장X)
			// 너비우선 탐색(연결된 노드에 모두 방문한다. ) 최소해 보장하나 이는 가중치의 이야기가 아니라 최단 경로를 의미(그래프 ppt 65pg 참고)
			// 큐를 사용 하여 인접한 노드들을 알파벳 순서로 추가하여 큐에 넣어준다.
				// 갤러리 참고
		
				
			//크루스칼 과 프림 알고리즘(ppt99pg 전후참고)(그리디 알고리즘 ppt 19pg 전후 위주로 !!!)
				// 크루스칼과 프림 알고리즘은 그리디이다.
					// 프림 D[v](그리디 알고리즘 ppt 30pg 참고)(갤러리에서 제시된 문제로도 생각해보기-- 일단 ppt로 완벽 숙지 )
						// 첫 시작 노드에서부터 인접한 다른 노드로 영역을 확장하고 여기에서 가장 큰 가중치를 가진 혹은 가장 작은 가중치를 가진 노드를 선택하고 이를 트리 영역에 추가한다.
						// 이후에 트리 영역에 해당되는 노드들의 인접 노드들 중에서 목적에따라 최적해를 성립시킬 수 있는 노드를 선택하여 영역에 추가한다.(갤러리 참고)
						// 단 이과정에서 사이클이 생기지 않도록 유의한다.
				// 각 알고리즘의 정의와 특징은 반드시 숙지하자...! (다익스트라 알고리즘 특히 강조!)
					// 시작은 프림과 동일 (아래 내용은 갤러리 참고, 사진 여러장)
					// 첫 시작은 인접으로 시작한다.
					// 만약 가중치의 최소해를 목적으로 한다면 영역에 들어있는 노드들에서 인접한 노드들 중 가장 작은 가중치로 빠지고 ...
					// 그러다보면 이미 도출된 값의 값을 수정하기도 한다...!
					// 최종적으로 완성된 수행 결과는 각 노드로 가는 최소해를 제시 가능하다.(즉, 다익스트라는 최적해를 보장한다.)
		//setcover에서 괄호 안에 내용 넣기 정도 는 해야한다.???
			//허프만 코드에서는 예제 60번과 61번 62번 느낌을 기억하고 준비하자!(예제랑 개념만을 인지하고 알고리즘 암기는 하지 말라)
				// 별개로 이러한 허프만 코드에서 가장 작은 노드를 골라 트리를 형성할때는 "힙을 사용해서 가장 작은 것만을 고른다."


			
