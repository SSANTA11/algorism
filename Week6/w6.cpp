
// 다익스트라 알고리즘은 음수 가중치가 없는 그래프에서 최단 경로를 찾는 알고리즘입니다.

// 부분 배낭 문제

// 배낭문제는 두가지 종류가 있다
// 1. 0-1 배낭 문제: 물건을 통째로 넣거나 안넣거나
// 2. 부분 배낭 문제: 물건을 쪼개서 넣을 수 있다
// 탐욕 알고리즘은 부분 배낭 문제에 적용할 수 있다
// 탐욕 알고리즘은 매 순간 최적이라고 생각되는 것을 선택하는 방법이다
// 탐욕 알고리즘은 항상 최적의 해를 보장하지는 않는다
// 부분 배낭 문제는 탐욕 알고리즘으로 최적의 해를 구할 수 있다

// Fractional Knapsack Problem 
// 입력: n개의 물건, 각 물건의 무게와 가치, 배낭의 용량C
// 출력: 배낭에  담은 물건 리스트 L과 배낭 속의 물건 가치의 합 V
// 1. 각 물건에 대해 단위 무게 당 가치를 계산한다.

// 2. 물건들을 단위 무게 당 가치를 기준으로 내림차순으로 정렬하고, 정렬된 물건 리스트를 S라고 하자.

// 3. L = ∅, w = 0, v = 0

// L은 배낭에 담을 물건 리스트, w는 배낭에 담긴 물건들의 무게의 합, v는 배낭에 담긴 물건들의 가치의 합

// 4. S에서 단위 무게 당 가치가 가장 큰 물건 x를 가져온다.

// 5. while w + (x의 무게) ≤ C

// 6. x를 L에 추가

// 7. w = w + (x의 무게)

// 8. v = v + (x의 가치)

// 9. x를 S에서 제거

// 10. S에서 단위 무게 당 가치가 가장 큰 물건 x를 가져온다.

// 11. If C - w > 0 // 배낭에 물건을 부분적으로 담을 여유가 있으면
// 12. 물건 x를(C - w) 만큼만 L에 추가
// 13. v = v + (C - w) 만큼의 x의 가치
// 14. return L, v

// 집합 커버 문제 
	// 예) 15분 내 거리 마을 사이 간 최소 학교 배치(?)--->setcover문제
	// ppt 76pg 전후
	// 전공서적 132pg 전후

	// 주의!: 처음엔 포괄되는 마을이 가장 많은 경우를 선택하고
	// 그 다음엔 첫 선택에 포함되는 마을을 제외한 나머지 마을이 가장 많은 경우를 선택하는 식으로 진행
	// 그러나 이는 최적해를 보장하지는 않는다.(대략적인 최적?해 느낌!!)

	// 도시계획에서 공공 기관 배치하기--->setcover문제
	// ppt 87pg 전후
	// 전공서적 133pg 전후

	// 작업스케줄링
	// ppt 90pg 전후
	// 전공서적 136pg 전후
	// 1 빠른 시작시간 작업 우선(Earliest start time first) 배정
	// 2 빠른 종료시간 작업 우선(Earliest finish time first) 배정
	// 3 짧은 작업 우선(Shortest job first) 배정
	// 4 긴 작업 우선(Longest job first) 배정

	// 위 4가지 중 1번 알고리즘을 제외하고 나머지는 항상 최적해를 찾지는 못함

	// 허프만 압축
	// ppt 99pg
	// 전공서적 140pg 
	// 빈도수가 높은 문자에 짧은 이진 코드 할당s
	// 빈도수가 낮은 문자에 긴 이진 코드 할당
	// 이는 용량을 줄이기 위해서 사용됨
	// prefix code(접두사 코드)를 반드시 지켜여한다.
	// 즉, 어떤 문자의 코드가 다른 문자의 코드의 접두사가 되어서는 안된다.
	// 허프만 트리(Huffman tree)를 구성하여 허프만 코드를 생성
	// 허프만 트리는 이진 트리로, 각 리프 노드에만 문자가 할당된다.